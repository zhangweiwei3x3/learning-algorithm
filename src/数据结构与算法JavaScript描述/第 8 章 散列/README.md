## 数据结构与算法JavaScript描述 -> 第 8 章 散列

## [散列的基本概念](http://blog.csdn.net/koself/article/details/7869453)

散列方法的主要思想是根据结点的关键码值来确定其存储地址：以关键码值K为自变量，通过一定的函数关系h(K)(称为散列函数)，计算出对应的函数值来，把这个值解释为结点的存储地址，将结点存入到此存储单元中。检索时，用同样的方法计算地址，然后到相应的单元里去取要找的结点。通过散列方法可以对结点进行快速检索。散列（hash，也称“哈希”）是一种重要的存储方式，也是一种常见的检索方法。

按散列存储方式构造的存储结构称为散列表（hash table）。散列表中的一个位置称为槽(slot)。散列技术的核心是散列函数(hash function)。 对任意给定的动态查找表DL，如果选定了某个“理想的”散列函数h及相应的散列表HT，则对DL中的每个数据元素X。函数值h（X.key）就是X在散列表HT中的存储位置。插入（或建表）时数据元素X将被安置在该位置上，并且检索X时也到该位置上去查找。由散列函数决定的存储位置称为散列地址。 因此，散列的核心就是：由散列函数决定关键码值(X.key)与散列地址h(X.key)之间的对应关系，通过这种关系来实现组织存储并进行检索。

一般情况下，散列表的存储空间是一个一维数组HT[M]，散列地址是数组的下标。设计散列方法的目标，就是设计某个散列函数h，0<=h( K ) < M；对于关键码值K，得到HT[i] = K。 在一般情况下，散列表的空间必须比结点的集合大，此时虽然浪费了一定的空间，但换取的是检索效率。设散列表的空间大小为M，填入表中的结点数为N，则称为散列表的负载因子（load factor，也有人翻译为“装填因子”）。建立散列表时，若关键码与散列地址是一对一的关系，则在检索时只需根据散列函数对给定值进行某种运算，即可得到待查结点的存储位置。但是，散列函数可能对于不相等的关键码计算出相同的散列地址，我们称该现象为冲突（collision），发生冲突的两个关键码称为该散列函数的同义词。在实际应用中，很少存在不产生冲突的散列函数，我们必须考虑在冲突发生时的处理办法。

因此，采用散列技术时需要考虑的两个首要问题是：

（1）如何构造(选择)使结点“分布均匀”的散列函数？

（2）一旦发生冲突，用什么方法来解决？ 


## 练习：
* **1、使用线性探测法创建一个字典，用来保存单词的定义。该程序需要包含两个部分：**

第一部分从文本文件中读取一组单词和它们的定义，并将其存入散列表；

第二部分让用户输入单词，程序给出该单词的定义。


* **2、使用开链法重新实现练习 1。**


* **3、读取一个文本文件，使用散列显示该文件中出现的单词和它们在文件中出现的次数。**